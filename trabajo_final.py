# -*- coding: utf-8 -*-
"""Trabajo final

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wMEL-lHRfJxhsOUALlmL1YvUrK5nJ6Xc

Trabajo final:

1. Estructura del trabajo:

* Carga de datos.
* Depuración: Homologación de categorías, tipos de datos.
* Tratamiento de datos nulos.
* Generación de bodegas de datos.
* Transformaciones: Aplicación de funciones para la creación de nuevas variables.
* Análisis descriptivo sobre las bases individuales y su relación: Plantearse 9 preguntas que le ayuden a tener un entendimiento de la información recolectada y le permitan estar más cerca de concluir sobre el tema analizado. Dar respuesta a estas preguntas a través de tablas y gráficos.
* En este punto, pueden complementar su análisis con alguna información adicional? ¿Qué más sería interesante ver en este análisis descriptivo? Buscar información y agregarla

2. Los archivos que se deben entregar son:

* Archivo colab con el código ordenado y documentado (comentarios y títulos)
* Fuentes de datos utilizadas.

3. Criterios de calificación:

* Cumplir con toda la estructura del trabajo (70%)
* Claridad (comentarios) y orden en el código (10%)
* Creatividad y capacidad de análisis (20%)

# **PAQUETES**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

"""# **CARGA DE DATOS**"""

from google.colab import drive
drive.mount('/content/drive')

bd1 = pd.read_csv('/content/drive/MyDrive/ANALITICA/BASES DE TRABAJO FINAL/COVID-19_Outcomes_by_Testing_Cohorts__Cases__Hospitalizations__and_Deaths.csv')
bd2 = pd.read_csv('/content/drive/MyDrive/ANALITICA/BASES DE TRABAJO FINAL/DOHMH_HIV_AIDS_Annual_Report (1).csv')
bd3 = pd.read_csv('/content/drive/MyDrive/ANALITICA/BASES DE TRABAJO FINAL/New_York_City_Leading_Causes_of_Death (1).csv')

"""# **BASES DE DATOS**

## Base de datos 1 COVID-19_Outcomes_by_Testing_Cohorts__Cases__Hospitalizations__and_Deaths
"""

bd1

# Cambiar el nombre de las columnas
df1 = bd1.copy()
df1.columns = ['fecha_extraccion', 'fecha_muestra', 'residentes_examinados', 'confirmados_covid', 'hospitalizaciones', 'muertes']
df1.head()

# Tipo de datos
df1.dtypes

# convertir las columnas de fecha a formato fecha
df1[['fecha_extraccion']] = df1[['fecha_extraccion']].apply(pd.to_datetime, format='%m/%d/%Y')
#df1[['fecha_muestra']] = df1[['fecha_muestra']].apply(pd.to_datetime, format='%m/%d/%Y')
df1.dtypes

"""Cuanto trato de cambiar el formato de los datos de la columna fecha_muestra, me sale un error que indica que estoy intentando crear un objeto Timestamp con una fecha y hora que están fuera del rango de valores permitidos por Pandas."""

# Revisar los datos de la columna fecha_muestra
df1[['fecha_muestra']].value_counts()

"""Con el codigo anterior se detecta un registro anormal, años que inician en 22"""

# filtrar las filas con los años 2299
df1[df1['fecha_muestra'].str[6:8] == '22'].tail(20)
#anios_nulos

"""Como el número de personas examinadas es 1 en cada fila o registro, consideramos que las filas se pueden eliminar ya que, esto no tendra mucha influencia en los resultados"""

# Eliminar filas donde el año de la columna fecha_muestra es igual a 2299
anios_nulos = df1['fecha_muestra'].str[6:8] == '22'
df1 = df1.drop(index=df1[anios_nulos].index)
df1

# convertir las columnas de fecha a formato fecha
df1[['fecha_muestra']] = df1[['fecha_muestra']].apply(pd.to_datetime, format='%m/%d/%Y')
df1.dtypes

df1.isnull().sum()

# Buscar si hay datos duplicados
if df1.duplicated().any():
    print("El DataFrame tiene filas duplicadas")
else:
    print("El DataFrame no tiene filas duplicadas")

"""## Base de datos 2 DOHMH_HIV_AIDS_Annual_Report"""

bd2.head()

# Cambiar el nombre de las columnas
df2 = bd2.copy()
df2.columns = ['año', 'distritos', 'UHF', 'genero', 'edad', 'raza/etnia', 'diagnosticos_vih', 'tasa_diagnostico_vih', 
               'diagnostico_concurrente_sida', '% linked to care within 3 months', 'diagnosticos_sida', 
               'tasa_diagnostico_sida', 'PLWDHI prevalence', '% viral suppression', 'muertes', 'tasa_muertes', 
               'tasa_ mortalidad_vih', 'tasa_mortalidad_no_relacionada_vih']
df2.head()

df2.dtypes

df2['distritos'].value_counts()

df2['UHF'].value_counts()

df2['genero'].value_counts()

# Agrupar la categoría "Transgender" a "All"
df2['genero'] = df2['genero'].replace('Transgender', 'All')
df2['genero'].value_counts()

df2['edad'].value_counts()

df2['raza/etnia'].value_counts()

df2['año'].value_counts()

df2.isnull().sum()

if df2.duplicated().any():
    print("El DataFrame tiene filas duplicadas")
else:
    print("El DataFrame no tiene filas duplicadas")

"""## Base de datos 3 New_York_City_Leading_Causes_of_Death"""

bd3.head()

# crear una copia de la base original
df3 = bd3.copy()
# Cambiar el nombre de las columnas
df3.columns = ['año', 'causa_de_muerte', 'genero', 'raza/etnia', 'muertes', 'tasa_mortalidad', 'tasa_mortalidad_ajustada']
df3.head()

# Tipo de datos de las variables
df3.dtypes

df3['causa_de_muerte'].unique()

df3['genero'].value_counts()

# agrupar en 'M' y 'F' con 'Male' y 'Female' respectivamente
df3['genero'] = df3['genero'].replace(['M', 'F'], ['Male', 'Female'])
df3['genero'].value_counts()

df3['raza/etnia'].unique()

# Convertir la columna "muertes", "tasa_mortalidad", y "tasa_mortalidad_ajustadaa" a tipo número
# df3['muertes'] = df3['muertes'].astype(int)

df3['muertes'].value_counts()

#  Filtrar y almacenar las filas que son registro '.' en la columna muertes
filas_puntos = df3.loc[df3['muertes'] == '.']
filas_puntos

"""En la columna 'muertes' donde el registro es un '.', las demas variables numericas tambien son un '.', por lo tanto, consideramos que no suman informacion al analisis y por ende las eliminaremos"""

# Eliminar las filas filtradas del DataFrame original
df3 = df3.drop(filas_puntos.index)
df3

# Filtrar y almacenar las filas que son registro '.' en la columan muertes
filas_puntos = df3.loc[df3['tasa_mortalidad'] == '.']
filas_puntos

# Reemplazar el registro '.' por NaN
df3['tasa_mortalidad'] = df3['tasa_mortalidad'].replace('.', np.nan)
df3

# Filtrar y almacenar las filas que son registro '.' en la columan muertes
filas_puntos = df3.loc[df3['tasa_mortalidad_ajustada'] == '.']
filas_puntos.head(20)

# Reemplazar el registro '.' por NaN
df3['tasa_mortalidad_ajustada'] = df3['tasa_mortalidad_ajustada'].replace('.', np.nan)
df3

# Organizar las filas en orden descendente según la columna 'fecha'
df3 = df3.sort_values('año', ascending=True)
df3

# Cambiar el tipo de dato de la columna muertes de object a int
df3['muertes'] = df3['muertes'].astype(int)
# Cambiar el tipo de dato de las columnas 'tasa_mortalidad', 'tasa_mortalidad_ajustada' de object a float
df3[['tasa_mortalidad', 'tasa_mortalidad_ajustada']] = df3[['tasa_mortalidad', 'tasa_mortalidad_ajustada']].astype(float)
df3.dtypes

df3.isnull().sum()

# Buscar si hay datos duplicados
if df3.duplicated().any():
    print("El DataFrame tiene filas duplicadas")
else:
    print("El DataFrame no tiene filas duplicadas")

"""## Unir Bases de Datos"""

# Extraer el año en una nueva columna 'Año'
df1['año'] = df1['fecha_muestra'].dt.year
df1

# maximo y minimo de año en cada base de datos
print(df1['año'].max()) #maximo
print(df1['año'].min())

print(df2['año'].max())
print(df2['año'].min())

print(df3['año'].max())
print(df3['año'].min()) #minimo

a = df1.groupby(['año'])[['muertes']].sum().reset_index()
a.rename(columns={'muertes': 'muertes_covid'}, inplace=True)
a

b = df2.groupby(['año'])[['muertes']].sum().reset_index()
b.rename(columns={'muertes': 'muertes_VIH'}, inplace=True)
b

c = df3.groupby(['año'])[['muertes']].sum().reset_index()
c.rename(columns={'muertes': 'muertes_otras'}, inplace=True)
c

muertes = pd.merge(b, c, how='outer', on = 'año').merge(a, how= 'outer', on = 'año')
muertes

"""# **PREGUNTAS**

## 1. Por mes cuantos confirmados de covid hubo y cuantas muertes
"""

#agregar una columna con el mes para un mejor análisis
df1['mes'] = df1['fecha_muestra'].dt.month_name()

df1

df1['mes_año'] = df1['fecha_muestra'].dt.strftime('%Y-%m')
df1

base = df1.groupby('mes_año')[['confirmados_covid', 'muertes']].sum().reset_index()
base

# Crear una figura y ejes para el gráfico de líneas
fig, ax = plt.subplots(figsize=(12, 6))

# Convertir la columna 'mes_año' en una categoría con el orden correcto de los meses
base['mes_año'] = pd.to_datetime(base['mes_año'])
base['mes_año'] = base['mes_año'].dt.strftime('%Y-%m')
meses_ordenados = sorted(base['mes_año'].unique())

# Ordenar el DataFrame base por la columna 'mes_año'
base['mes_año'] = pd.Categorical(base['mes_año'], categories=meses_ordenados, ordered=True)
base = base.sort_values('mes_año')

x_pos = base['mes_año']

# Graficar las líneas de los promedios de confirmados y hospitalizados
ax.plot(x_pos, base['muertes'], marker='o', label='Muertes')
ax.plot(x_pos, base['confirmados_covid'], marker='o', label='Confirmados')

# Establecer etiquetas y título del gráfico
ax.set_xlabel('Meses')
ax.set_ylabel('Casos')
ax.set_title('Confirmados VS Muertes de COVID')

# Establecer las etiquetas de los días de la semana en el eje x
ax.set_xticks(x_pos)
ax.set_xticklabels(x_pos, rotation=90)

# Mostrar una leyenda con las etiquetas de los promedios
ax.legend()

# Ajustar los valores del eje y en incrementos de 50 en 50
ax.set_yticks(range(21, 59437292, 2000000))

# Mostrar el gráfico de líneas
plt.show()

# Crear una figura y ejes para el gráfico de líneas
fig, ax = plt.subplots(figsize=(12, 6))

# Convertir la columna 'mes_año' en una categoría con el orden correcto de los meses
base['mes_año'] = pd.to_datetime(base['mes_año'])
base['mes_año'] = base['mes_año'].dt.strftime('%Y-%m')
meses_ordenados = sorted(base['mes_año'].unique())

# Ordenar el DataFrame base por la columna 'mes_año'
base['mes_año'] = pd.Categorical(base['mes_año'], categories=meses_ordenados, ordered=True)
base = base.sort_values('mes_año')

x_pos = base['mes_año']

# Graficar las líneas de los promedios de confirmados y hospitalizados
ax.plot(x_pos, base['muertes'], marker='o', label='Muertes')


# Establecer etiquetas y título del gráfico
ax.set_xlabel('Meses')
ax.set_ylabel('Casos')
ax.set_title('Confirmados VS Muertes de COVID')

# Establecer las etiquetas de los días de la semana en el eje x
ax.set_xticks(x_pos)
ax.set_xticklabels(x_pos, rotation=90)

# Mostrar una leyenda con las etiquetas de los promedios
ax.legend()

# Ajustar los valores del eje y en incrementos de 50 en 50
ax.set_yticks(range(21, 6075223, 200000))

# Mostrar el gráfico de líneas
plt.show()

"""En la gráfica se evidencia que los casos confirmados de COVID tienen poca incidencia en las muertes, únicamente en el mes de abril durante el año 2020 donde hubo un enorme aumento de los casos de COVID, se logra ver un pico en las muertes, en los demas meses el numero de casos y muertes tienen comportamientos similares pero no se logra ver unra relación clara entre ambos, por ello se decide graficar las muertes en una grafica nueva que permita ver mejor el comportamiento, si bien se logra identificar mejor la relación sigue teniendo una desviación bastante alta.

## 2. cual es el promedio por dia de la semana de confirmados y hospitalizaciones por covid
"""

# Obtener el día de la semana para cada fecha
df1['dia_semana'] = df1['fecha_muestra'].dt.day_name()
df1.head()

# promedio por día de la semana de los confirmados y hospitalizados
promedio_por_dia = df1.groupby('dia_semana')[['confirmados_covid', 'hospitalizaciones']].mean()
promedio_por_dia

# Crear una figura y ejes para el gráfico de líneas
fig, ax = plt.subplots(figsize=(12, 6))

# Obtener los nombres de los días de la semana y su posición en el eje x
dias_semana = promedio_por_dia.index
x_pos = range(len(dias_semana))

# Graficar las líneas de los promedios de confirmados y hospitalizados
ax.plot(x_pos, promedio_por_dia['confirmados_covid'], marker='o', label='Confirmados')
ax.plot(x_pos, promedio_por_dia['hospitalizaciones'], marker='o', label='Hospitalizaciones')

# Establecer etiquetas y título del gráfico
ax.set_xlabel('Día de la semana')
ax.set_ylabel('Promedio')
ax.set_title('Promedio por día de la semana de confirmados y hospitalizaciones')

# Establecer las etiquetas de los días de la semana en el eje x
ax.set_xticks(x_pos)
ax.set_xticklabels(dias_semana)

# Mostrar una leyenda con las etiquetas de los promedios
ax.legend()

# Ajustar los valores del eje y en incrementos de 50 en 50
ax.set_yticks(range(100, 1800, 150))

# Mostrar el gráfico de líneas
plt.show()

"""El día de la semana con más número de casos confirmados es el lunes y el de menos casos confirmados es el domingo. Esto sucede de igual manera para las hospitalizaciones

Los días de la semana con números altos de confirmados también tienden a tener altos casos de hospitalizaciones. Esto indica una posible correlación entre el número de casos confirmados y la necesidad de hospitalización.

## 3. Cual es la tasa de mortalidad y la de hospitalizaciones por dia del mes
"""

# Agrupar los datos por día del mes y calcular la suma de 'examinados', 'hospitalizaciones' y 'muertes'
datos_por_dia = df1.groupby(df1['fecha_muestra'].dt.day)['residentes_examinados', 'hospitalizaciones', 'muertes'].sum()

# Calcular la tasa de mortalidad y la tasa de hospitalización por día del mes
datos_por_dia['tasa_mortalidad'] = (datos_por_dia['muertes'] / datos_por_dia['residentes_examinados']) * 100
datos_por_dia['tasa_hospitalizacion'] = (datos_por_dia['hospitalizaciones'] / datos_por_dia['residentes_examinados']) * 100

datos_por_dia[['tasa_mortalidad', 'tasa_hospitalizacion']]

# Crear una figura y ejes para el gráfico de barras apiladas
fig, ax = plt.subplots(figsize = (15,5))

# Graficar las líneas de la tasa de mortalidad y la tasa de hospitalización
ax.plot(datos_por_dia.index, datos_por_dia['tasa_mortalidad'], marker='o', label='Tasa de mortalidad')
ax.plot(datos_por_dia.index, datos_por_dia['tasa_hospitalizacion'], marker='o', label='Tasa de hospitalizaciones')

# Configuraciones adicionales del gráfico
ax.set_xlabel('Día del mes')
ax.set_ylabel('Tasa (%)')
ax.set_title('Tasa de mortalidad y tasa de hospitalizaciones por dia del mes')
ax.legend()

# Mostrar el gráfico de líneas
plt.show()

"""La tasa de mortalidad varía a lo largo del mes. La tasa más alta se registra el día 31, mientras que las tasas más bajas se observan en los días 15, 16 y 18.

Al igual que la tasa de mortalidad, la tasa de hospitalización también muestra variaciones a lo largo del mes. La tasa más alta se registra el día 31, mientras que las tasas más bajas se observan en los días 15 y 18.

En general, se puede observar una tendencia de aumento y disminución conjunta entre las tasas de mortalidad y hospitalización. En los días con tasas más altas de hospitalización, también se observan tasas más altas de mortalidad.

No se identifica un patrón claro en la variación de las tasas de mortalidad y hospitalización a medida que avanza el mes. Sin embargo, se puede notar que las tasas tienden a fluctuar sin seguir una secuencia definida.

## 4. ¿En qué año fueron diagnosticados más mujeres y en cual los hombres por VIH?
"""

#debido a la cantidad de vatriables se resuekve crear dos gráficas una que muestre por año y la otra por genero
base2 = df2.groupby(['año'])[['diagnosticos_vih', 'diagnosticos_sida']].sum().reset_index()
base2

from traitlets.traitlets import ValidateHandler
a = base2[['año','diagnosticos_vih']].rename(columns ={'diagnosticos_vih':'valores'})
b = base2[['año','diagnosticos_sida']].rename(columns ={'diagnosticos_sida':'valores'})
a['categoria'] = 'VIH'
b['categoria'] = 'SIDA'
base2 = pd.concat([a,b])

base2

base3 = base2.groupby(['categoria', 'año'])[['valores']].sum().reset_index()
base3

# crear dataset
base1 = df2.query('genero != "All"').groupby(['genero'])[['diagnosticos_vih', 'diagnosticos_sida']].sum().reset_index()

# crear gráfica
fig = px.bar(base1,  x='genero', y=['diagnosticos_vih', 'diagnosticos_sida'], barmode= 'group', title ='<b>Diagnosticos de VIH y SIDA por genero<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Género',
    yaxis_title = 'Diagnosticos',
    template = 'simple_white',
    title_x = 0.5,
    legend_title = '<b>Genero<b>')

fig.show()

"""En el gráfico se evidenca que más del doble de las personas diagnosticas tanto para VIH como SIDA son de género masculino y que en los hombres es más común que se llegue a un diagnóstico de SIDA, es decir, es más frecuente que los hombres lleguen a un nivel más grave de la enfermedad. Mientras que en las mujeres es más frecuente el VIH."""

# crear gráfica
fig = px.bar(base3,  x='año', y='valores', color='categoria', barmode= 'group' ,color_discrete_map = {'Female': 'fuchsia', 'Male': '#0099ff'}, title ='<b>Diagnósticos de VIH y SIDA por año<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Año',
    yaxis_title = 'Diagnosticos',
    template = 'simple_white',
    title_x = 0.5,
    legend_title = '<b>Diagnóstico<b>')

fig.show()

"""En la gráfica se evidencia que durante el año 2012 hubo un aumento considerable de los casos de SIDA, sería de gran importancia encontrar la causa de este notorio aumento de diagnóstocs, además en el añp que hubo menos diagnósticos es en el 2015, podemos ver que a partir del año 2013 y hasta el 2015 se nota una tendencia a la baja, sería interesante realizar un análisis de años posteriores y ver si esta tendencia continua.

Para el caso del VIH por año se observa que los diagnósticos de VIH suelen ser muy estables, también que el número de diagnósticos por año ha estado disminuyendo, sin embargo el descenso es lento.

##  5. Por rango de edad cual fue el promedio de diagnósticos de sida y vih
"""

estadisticas = df2.query('edad != "All"').groupby(['edad'])['diagnosticos_vih', 'diagnosticos_sida'].mean().reset_index()
estadisticas

# Crear una figura y ejes para el gráfico de líneas
fig, ax = plt.subplots(figsize=(12, 6))

# Obtener los nombres de los días de la semana y su posición en el eje x

x_pos = estadisticas['edad']

# Graficar las líneas de los promedios de confirmados y hospitalizados
ax.plot(x_pos, estadisticas['diagnosticos_vih'], marker='o', label='VIH')
ax.plot(x_pos, estadisticas['diagnosticos_sida'], marker='o', label='SIDA')

# Establecer etiquetas y título del gráfico
ax.set_xlabel('Edad')
ax.set_ylabel('Promedio')
ax.set_title('Promedio por día de la semana de confirmados y hospitalizaciones')

# Establecer las etiquetas de los días de la semana en el eje x
ax.set_xticks(x_pos)
ax.set_xticklabels(estadisticas['edad'])

# Mostrar una leyenda con las etiquetas de los promedios
ax.legend()

# Ajustar los valores del eje y en incrementos de 50 en 50
ax.set_yticks(range(0, 30, 1))

# Mostrar el gráfico de líneas
plt.show()

"""En general el VIH suele estar por encima del promedio entre las edades de 13 a 49 años, luego el SIDA pasa a estar levemente por encima del promedio de diagnósticos de VIH, en promedio se diagnóstican más personas con VIH entre el rango de edad de entre los 20 y 29 años, para el caso del SIDA el rango promedio más alto de diagnósticos suele estar entre los 40 y 49 años, lo que podría indicar que son personas que no realizan su tratamiento adecuadamente.

## 6. Como es la distribución en los diagnosticos de SIDA y los de VIH según la raza/etnia
"""

# Calcular la distribución de raza/etnia sumando la columna "diagnosticos_sida" y filtrar para excluir la categoría "Other/Unknown"
distribucion_raza_etnia = df2[df2['raza/etnia'] != 'Other/Unknown'].groupby('raza/etnia')['diagnosticos_sida'].sum()

# Calcular la distribución de diagnósticos de VIH sumando la columna "diagnosticos_vih" y filtrar para excluir la categoría "Other/Unknown"
distribucion_vih = df2[df2['raza/etnia'] != 'Other/Unknown'].groupby('raza/etnia')['diagnosticos_vih'].sum()

# Crear un DataFrame con los datos de distribución de raza/etnia y diagnósticos de VIH
tabla_datos = pd.DataFrame({
    'Raza/Etnia': distribucion_raza_etnia.index,
    'Diagnósticos SIDA': distribucion_raza_etnia.values,
    'Diagnósticos VIH': distribucion_vih.values
})

tabla_datos

# Crear una figura y ejes para los gráficos de torta
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 5))

# Configurar los datos y etiquetas del primer gráfico de torta (diagnósticos de SIDA)
pie1 = ax1.pie(distribucion_raza_etnia, autopct='%1.0f%%', textprops={'fontsize': 10.5})
ax1.set_title('Distribución de raza/etnia para los diagnósticos de SIDA')

# Configurar los datos y etiquetas del segundo gráfico de torta (diagnósticos de VIH)
pie2 = ax2.pie(distribucion_vih, autopct='%1.0f%%', textprops={'fontsize': 10.5})
ax2.set_title('Distribución de raza/etnia para los diagnósticos de VIH')

# Crear una leyenda común para ambos gráficos de torta
fig.legend(distribucion_raza_etnia.index, title='Raza/Etnia', loc='center')

# Ajustar el espaciado entre los gráficos
fig.tight_layout()

plt.show()

"""La distribución de diagnósticos de SIDA y VIH varía significativamente según la raza/etnia. Esto indica que existen disparidades en la prevalencia de estas enfermedades entre diferentes grupos étnicos.

La categoría "All" es la categoría con el mayor número de diagnósticos de VIH y el segundo mayor número de diagnósticos de SIDA, lo que indica que los diagnósticos de VIH son más frecuentes que los de SIDA en general.

La categoría "Asian/Pacific Islander" se destaca por tener un alto número de diagnósticos de SIDA en comparación con otras categorías, pero un número relativamente bajo de diagnósticos de VIH.

La categoría "Black" tiene un número considerablemente alto de diagnósticos tanto de SIDA como de VIH.

La categoría "Latino/Hispanic" tiene un número moderado de diagnósticos tanto de SIDA como de VIH.

La categoría "White" muestra los números más bajos en términos absolutos.

## 7. ¿Cuál fue la principal causa de muerte 'Non-Hispanic Black' y 'Non-Hispanic
"""

base3 = df3[df3['raza/etnia'].isin(['Non-Hispanic Black', 'Non-Hispanic White'])]
base3 = base3.groupby(['año', 'raza/etnia'])[['muertes']].sum().reset_index()

base3

# crear gráfica
fig = px.bar(base3,  x='año', y='muertes', color ='raza/etnia', barmode= 'group', title ='<b>Muertes para los no hispanos por año<b>')

# agregar detalles a la gráfica
fig.update_layout(
    xaxis_title = 'Año',
    yaxis_title = 'Muertes',
    template = 'simple_white',
    title_x = 0.5,
    legend_title = '<b>Raza/etnia<b>')

fig.show()

"""En general el comportamiento de la mortalidad a través de los años es muy estable para ambas razas, pero vemos que en general los no hispanos blancos suelen tener más muertes.

## 8. Cual fue el top 3 de enfermedades que registró más muestes en los últimos 5 años
"""

# crear un base para las variables que vamos a usar
base = df3[['año', 'causa_de_muerte', 'muertes']]
# Filtrar los últimos 5 años
df_filtrado = base[base['año'] >= 2015]
# Agrupar por año y causa de muerte
top_por_año = df_filtrado.groupby(['año', 'causa_de_muerte'])['muertes'].sum().reset_index().sort_values(by=['año', 'muertes'], ascending=[True, False])
# Obtener las tres primeras filas de cada grupo (año)
top_tres = top_por_año.groupby('año').head(3)
top_tres

# cambiar el nombre de las enfermedades
# Crear un diccionario con los cambios de nombres
nombres = {'Diseases of Heart (I00-I09, I11, I13, I20-I51)': 'Enfermedades del Corazón',
            'Malignant Neoplasms (Cancer: C00-C97)': 'Neoplasmas malignos (Cáncer)',
                   'All Other Causes': 'Todas las demás causas'}

# Aplicar los cambios de nombres a la variable deseada
top_tres['causa_de_muerte'] = top_tres['causa_de_muerte'].replace(nombres)

# Crear una figura y ejes para el gráfico de barras
fig, ax = plt.subplots(figsize=(10, 6))

# Obtener los valores de los años y las enfermedades
anios = top_tres['año'].unique()
enfermedades = top_tres['causa_de_muerte'].unique()

# Configurar el ancho de las barras
bar_width = 0.6 / len(enfermedades)

# Generar el gráfico de barras
for i, enfermedad in enumerate(enfermedades):
    muertes = top_tres[top_tres['causa_de_muerte'] == enfermedad]['muertes']
    x = np.arange(len(anios)) + i * bar_width
    ax.bar(x, muertes, width=bar_width, label=enfermedad)

# Configurar las etiquetas del eje x y el título del gráfico
ax.set_xlabel('Año')
ax.set_ylabel('Número de muertes')
ax.set_title('Top 3 enfermedades con más muertes por año')

# Configurar las etiquetas del eje x
ax.set_xticks(np.arange(len(anios)))
ax.set_xticklabels(anios)

# Agregar la leyenda
ax.legend(title='Causas de muerte', bbox_to_anchor=(1, 0.9))

# Mostrar el gráfico de barras
plt.show()

"""Al observar los datos, las tres principales causas de muerte en los últimos cinco años son: Enfermedades del Corazón, la cual ha sido consistente a lo largo de los años, con un número significativo de muertes registradas en cada año; Neoplasmas malignos (Cáncer), también ha sido una causa importante de muerte; y por último estan todas las demás causas, esta categoría incluye causas de muerte que no se especifican como enfermedades del corazón o neoplasmas malignos. Aunque el número de muertes en esta categoría es menor en comparación con las dos anteriores, aún representa un número significativo de muertes.

## 9. cual fue el minimo, el maximo, el promedio, la mediana y la desviacion estandar de las muertes por año
"""

# Calcular las estadísticas por fecha y categoría
estadisticas = muertes.groupby(['año'])['muertes_VIH','muertes_otras','muertes_covid'].agg(['mean', 'median', 'max', 'min']).reset_index()
estadisticas

"""Para las muertes por VIH, Los datos proporcionados muestran valores de muertes por VIH en los años 2011 (121,570) y 2012 (119,934).
Los datos no están disponibles para otros años, lo que dificulta una evaluación más completa.
En las muertes por otras causas se evidencia que los valores son bastante consistentes en la tabla, con una media cercana a 53,000.
No se proporcionan datos específicos para cada año, como tendencias o variaciones significativas.
Según las muertes por COVID, los datos disponibles solo están disponibles para los años 2020 (12,216,225) y 2021 (808,279), teniendo en cuenta que es una enfermadad muy reciente.
Estos valores son considerablemente más altos en comparación con las muertes por otras causas en los años anteriores.
"""

muertes.describe()

"""Muertes VIH:
Según la columna "count", solo hay datos disponibles para 5 años en total.
La media de muertes por VIH es de aproximadamente 59,386, con una desviación estándar de 56,025.
El valor mínimo registrado es de 17,624 y el máximo es de 121,570.
Dado que solo hay datos para un subconjunto de años, no se pueden obtener conclusiones claras sobre las tendencias a lo largo del tiempo.


Muertes por otras causas:
Según la columna "count", hay datos disponibles para 13 años en total.
La media de muertes por otras causas es de aproximadamente 53,643, con una desviación estándar de 873.
El valor mínimo registrado es de 52,420 y el máximo es desconocido debido a los datos faltantes.
No se puede determinar una tendencia clara ya que los datos para cada año no están disponibles.

Muertes por COVID:
Según la columna "count", hay datos disponibles para 2 años en total.
La media de muertes por COVID es de aproximadamente 6,512,252, con una desviación estándar de 8,066,636.
El valor mínimo registrado es de 808,279 y el máximo es de 12,216,225.
No se pueden obtener conclusiones claras sobre las tendencias a lo largo del tiempo debido a la falta de datos para la mayoría de los años.
"""